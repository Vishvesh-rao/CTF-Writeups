from Crypto.Util.number import long_to_bytes
from RSA_Attacks import CRT_attack,fermats_atk
from gmpy import *
from data import *

######################
#calculating p
######################

n1 = n[0]
n2 = n[1]
n3 = n[2]
n4 = n[3]

c1 = c[0]
c2 = c[1]
c3 = c[2]
c4 = c[3]

e=4

p = CRT_attack(n1,n2,n3,n4,c1,c2,c3,c4,e)
print("value of p is: {}\n".format(p))

########################
# calculating e1 and e2
########################

#---------------e1

e1 = root(ce1,42)[0]
assert(pow(e1,ee1,n11)==ce1)
print("value of e1 is: {}".format(e1))

#---------------e2

for k in range(100000):
	val = root(ce2+k*n11,3)
	if(val[1]):
		e2 = val[0] - tmp
print("value of e2 is: {}\n".format(e2)) 

assert(pow(e1,ee1,n11)==ce1)
assert(pow(e2+tmp,ee2,n11)==ce2)

####################
#calculating hint
####################

n,c,e=n12,c12,e12
q1p,q1q = fermats_atk(n12)
print("value of q1p is: {}".format(q1p))
print("value of q1q is: {}\n".format(q1q))
phi = (q1q-1)*(q1p-1)
d = invert(e,phi)
hint = long_to_bytes(pow(c,d,n))
print("value of hint is: {}\n".format(hint))

####################
#calculating flag
####################

q1 = q1p
c1_modq = c_flag % q1
GCD1 = gcd(e1,q1-1)
d1 = invert(e1/GCD1,q1-1)
c1_modq = pow(c1_modq,d1,q1)
flag = root(c1_modq,2)[0]
print("the flag is: {}".format(long_to_bytes(flag)))

